# BlockTeteries

### 1. 프로젝트 개요

이 프로젝트는 간단하지만 중독성 있는 블록 퍼즐 게임입니다. 플레이어는 다양한 모양의 블록을 드래그 앤 드롭 방식으로 보드에 배치하여 가로 또는 세로줄을 완성하고 점수를 얻는 것을 목표로 합니다. 보드에 더 이상 블록을 놓을 공간이 없으면 게임이 종료됩니다.

---

### 2. 드래그 앤 드롭 시스템 🕹️

이 게임은 **DragDropHandler.cs** 스크립트를 통해 직관적인 드래그 앤 드롭 시스템을 구현했습니다.

* **시작(OnBeginDrag)**: 블록을 누르는 순간, 블록의 원래 위치와 부모 오브젝트를 저장합니다. 드래그 중 다른 UI 위에 보이도록 캔버스의 최상위 요소로 이동시킵니다.
* **이동(OnDrag)**: 드래그하는 동안 블록은 마우스 위치를 따라 이동합니다. 동시에, **Board.cs**의 **ShowPreview** 메서드를 호출하여 블록을 놓을 수 있는 위치에 반투명한 미리보기 이미지를 보여줍니다.
* **종료(OnEndDrag)**: 드래그를 멈추면, 블록이 놓인 위치의 유효성을 **Board.cs**의 **CanPlace** 메서드로 확인합니다.
    * **배치 성공**: 유효한 위치에 놓이면, **Board.PlaceBlock** 메서드를 호출하여 블록을 보드에 고정하고 블록 오브젝트를 파괴합니다.
    * **배치 실패**: 유효하지 않은 위치이거나 놓을 수 없는 경우, 블록은 원래의 시작 위치로 되돌아갑니다.

---

### 3. 보드 및 게임 로직 🧩

게임의 핵심 로직은 **Board.cs** 스크립트에서 관리합니다. 2차원 배열인 `grid`를 사용하여 보드 슬롯의 상태를 추적합니다.

* **블록 배치(PlaceBlock)**: 블록이 성공적으로 배치되면, 블록의 모양 정보에 따라 해당 보드 슬롯들의 상태를 **점유(isOccupied = true)**로 변경하고 블록의 이미지를 적용합니다.
* **줄/열 삭제(CheckForClearedLines)**: 블록이 배치된 후, 가로 또는 세로로 모든 슬롯이 채워진 줄이 있는지 확인합니다. 완성된 줄이 발견되면 해당 슬롯들의 점유 상태를 **해제(isOccupied = false)**하여 보드를 비우고, 플레이어의 점수를 증가시킵니다.
* **게임 오버(CanAnyBlockBePlaced)**: 현재 남아있는 모든 블록들을 보드의 어떤 위치에도 놓을 수 없는지 확인합니다. 이 조건을 만족하면 게임 오버 상태로 전환됩니다.

---

### 4. 게임 상태 및 UI 관리 🔄

**PuzzleBlockManager.cs**, **PanelControl.cs**, **GameOverPanel.cs** 등의 스크립트가 게임의 전반적인 상태와 UI를 제어합니다.

* **블록 생성(PuzzleBlockManager.cs)**: 게임 시작 시 또는 모든 블록이 사용된 후에 새로운 3개의 블록 세트를 무작위로 생성합니다.
* **게임 오버 패널**: 게임 오버 조건이 충족되면 **gameOverPanel** 오브젝트를 활성화하여 플레이어에게 게임 오버 메시지를 보여줍니다.
* **재시작 및 종료**: **GameOverPanel.cs** 스크립트는 게임 오버 패널의 버튼 기능을 정의합니다.
    * `retryButton` 클릭 시: 현재 `Block` 씬을 다시 로드하여 게임을 재시작합니다.
    * `quitButton` 클릭 시: `Main Menu` 씬으로 돌아갑니다.

---

### 5. 소감

간단해 보이는 게임이었지만, 막상 개발을 시작하니 드래그 앤 드롭, 블록 배치 유효성 검사, 줄 삭제 등 다양한 기능이 필요하다는 것을 깨달았습니다. 예상했던 것보다 많은 시간과 노력이 소요되었지만, 이런 과정을 통해 간단한 게임도 수많은 기능과 복잡한 로직의 결합으로 이루어진다는 것을 배우는 좋은 계기가 되었습니다.
